{{- if hasKey .Values "debug" }}
apiVersion: v1
kind: Pod
metadata:
  name: debug-msi
spec:
  containers:
    - name: azure-cli
      image: mcr.microsoft.com/azure-cli:2.43.0
      resources:
        {{- toYaml .Values.resources | nindent 8 }}
      command:
        - "/bin/sh"
        - "-c"
        - "sleep infinity"
      env:
        - name: AZURE_FEDERATED_TOKEN_FILE
          value: /var/run/secrets/kubernetes.io/serviceaccount/token
        - name: AZURE_AUTHORITY_HOST
          value: https://login.microsoftonline.com/  
      volumeMounts:
      - name: aad-msi-token
        mountPath: /var/run/secrets/kubernetes.io/serviceaccount          
      nodeSelector:
        kubernetes.io/os: linux
  volumes:
    - name: aad-msi-token
      secret:
        secretName: aad-msi-auth-token
        optional: false # ensure the secret is there
{{- end }}        

## to make this work, we need to copy the token to the namespace:
# kubectl get secret aad-msi-auth-token -n kube-system -o yaml \
#   | sed "s/namespace: kube-system/namespace: <your-namespace>/" \
#   | kubectl apply -f -
# or alternativly use cross-namespace secret mounting:
# ex:
# apiVersion: rbac.authorization.k8s.io/v1
# kind: Role
# metadata:
#   namespace: kube-system
#   name: secret-reader
# rules:
#   - apiGroups: [""]
#     resources: ["secrets"]
#     resourceNames: ["aad-msi-auth-token"]
#     verbs: ["get"]
# ---
# kind: RoleBinding
# apiVersion: rbac.authorization.k8s.io/v1
# metadata:
#   name: secret-reader-binding
#   namespace: kube-system
# subjects:
#   - kind: ServiceAccount
#     name: <your-service-account>
#     namespace: <your-namespace>
# roleRef:
#   kind: Role
#   name: secret-reader
#   apiGroup: rbac.authorization.k8s.io